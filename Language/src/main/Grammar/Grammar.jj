
options
{
    DEBUG_PARSER=false;
    DEBUG_TOKEN_MANAGER=false;
}

PARSER_BEGIN(Parser)

package parser;

import nodes.*;
import nodes.primitives.*;
import nodes.arithmetic.*;
import nodes.relation.*;
import nodes.references.*;
import nodes.logic.*;
import nodes.conditional.*;
import state.*;
import types.*;
import java.io.PrintStream;
import java.util.List;
import java.util.ArrayList;


public class Parser {
	PrintStream out;

	public void setOutputStream(PrintStream out)
    {
    	this.out = out;
    }
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN :
{
  < DOT :  "." > |
  < COMA : "," > |
  < ADD : "+" > |
  < SUB : "-" > |
  < MULT : "*" > |
  < DIV : "/" > |
  < EXCL : "!" > |
  < TILDE : "~" > |
  < CONJ : "&&" > |
  < EAGER_CONJ : "&" > |
  < DISJ : "||" > |
  < EAGER_DISJ : "|" > |
  < EQUALS : "=" > |
  < ASSIGNMENT : ":=" > |
  < EQEQ : "==" > |
  < EXCL_EQUALS : "!=" > |
  < GREATER : ">" > |
  < LESS : "<" > |
  < GR_EQUALS : ">=" > |
  < LE_EQUALS : "<=" > |
  < ARROW : "->" > |
  < SEMICOLON: ";" > |
  < SCSC: ";;" > |
  < COLON: ":" > |
  < LPAR : "(" > |
  < RPAR : ")" > |
  < LCUR : "{" > |
  < RCUR : "}" >
//  |
//  < STAT_ENDS: (<SEMICOLON> | <NL>)>
//  |
}

//Reserved words
TOKEN : {
	< LET: "let" > |
	< END: "end" > |
	< IN: "in" > |
	< TRUE: "true" > |
   	< FALSE: "false" > |
   	< INT: "int" > |
   	< FLOAT: "float" > |
   	< NEW: "new" > |
   	< AS: "as" > |
   	< IF: "if" > |
   	< THEN: "then" > |
   	< ELSE: "else" > |
   	< WHILE: "while" > |
	< DO: "do" > |
   	< INSTANCEOF: "instanceof" > |
   	< PRINTLN: "println" > |
   	< PRINT: "print" >
}

TOKEN : {
	< INTEGER_LITERAL: (<DIGIT>) + > |
	< FLOAT_LITERAL: (<DIGIT>)+ "." (<DIGIT>)+ > |
	< IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*> |
	< #LETTER: ["a"-"z","A"-"Z"]> |
	< #DIGIT: ["0"-"9"]>
}

ASTNode Start():
{
//	List<ASTNode> nodes = new ArrayList<>();
	ASTNode node, node2;
}
{
//   (node = Statment() ((<STAT_ENDS> | <EOF>) Statment())* (<EOF>)?
//   {return node;}
//   )?
    node = Sequence() <SCSC>
    {return node;}

}

ASTNode Sequence() :
{
	ASTNode node, node2;
}
{
	node = Statment() ( <SEMICOLON> node2 = Sequence()
    	{
        	node = new ASTSequence(node,node2);
    	}
    )*
    {return node;}
}

ASTNode Statment() :
{
	ASTNode node;
}
{
	(
		node = Expression()
		|
		node = While()
	)
    { return node; }
}

ASTStatement While() :
{
	ASTNode cond, body;
}
{
	<WHILE> cond = Sequence() <DO> body = Sequence() <END>
	{ return new ASTWhile(cond,body); }
}

ASTNode Expression() :
{
    ASTNode node;
}
{
    node=Disjunction()
    { return node; }
}


ASTNode Disjunction() :
{
	Token op;
    ASTNode node,node2;
}
{
    node = Conjunction() ((op = <DISJ> | op = <EAGER_DISJ>) node2 = Conjunction()
    	{
		 	switch(op.kind)
         	{
         		case EAGER_DISJ:
 					node = new ASTEagerOr(node,node2);
 					break;
 				case DISJ:
 					node = new ASTOr(node,node2);
 					break;
         	}
 		}
    )*
    { return node; }
}

ASTNode Conjunction() :
{
	Token op;
    ASTNode node,node2;
}
{
    node = Equality() ((op = <CONJ> | op = <EAGER_CONJ>) node2 = Equality()
    	{
		 	switch(op.kind)
         	{
         		case EAGER_CONJ:
 					node = new ASTEagerAnd(node,node2);
 					break;
 				case CONJ:
 					node = new ASTAnd(node,node2);
 					break;
         	}
 		}
    )*
    { return node; }
}

ASTNode Equality() :
{
    Token op;
    ASTNode node,node2;
}
{
    node = Comparison() (( op=<EQEQ> | op=<EXCL_EQUALS> )  node2=Comparison()
    	{
			switch(op.kind)
   			{
   				case EQEQ:
   					node = new ASTEqual(node,node2);
   					break;
   			    case EXCL_EQUALS:
   			    	node = new ASTNotEqual(node,node2);
   			    	break;
   			}
   		}
    )*
    { return node; }
}

ASTNode Comparison() :
{
    Token op;
    ASTNode node,node2;
}
{
    node = AddSubExpression() (( op=<GREATER> | op=<LESS> | op=<GR_EQUALS> | op=<LE_EQUALS> )  node2=AddSubExpression()
    	{
			switch(op.kind)
   			{
   				case GREATER:
   					node = new ASTGreater(node,node2);
   					break;
   				case GR_EQUALS:
   					node = new ASTGreaterEqual(node,node2);
   					break;
   			    case LESS:
   			    	node = new ASTLess(node,node2);
   			    	break;
   			    case LE_EQUALS:
   			    	node = new ASTLessEqual(node,node2);
   			    	break;
   			}
   		}
    )?
    { return node; }
}

ASTNode AddSubExpression() :
{
    Token op;
    ASTNode node, node2;
}
{
    node = Term() (( op=<ADD> | op=<SUB> )  node2=Term()
    	{
			if (op.kind == ADD)
        		node = new ASTAddition(node,node2);
  			else
  				node = new ASTSubtraction(node,node2);
		}
    )*
    { return node; }
}

ASTNode Term() :
{
	ASTNode node;
	Token op;
}
{
	node = AsType()
	(
		node = Assignment(node)
		|
		node = MultDivExpression(node)
	)
	{ return node; }
}

ASTNode MultDivExpression(ASTNode node) :
{
    Token op;
    ASTNode node2;
}
{
    (( op=<MULT> | op=<DIV> ) node2 = Term()
		{
			if (op.kind == MULT)
    	    	node = new ASTMultiplication(node,node2);
			else
				node = new ASTDivision(node,node2);
		}
    )*
    { return node; }
}

IType NumberType() :
{
	IType t;
}
{
	(
		<FLOAT> { t = FloatType.value; }
		|
		<INT> {t = IntType.value; }
	)
    { return t; }
}


ASTNode AsType() :
{
	IType type = null;
    ASTNode node;
}
{
	node = Unary() (<AS> type = NumberType() )?
	{
		if (type==null)
    	   	return node;
		else
    	    return new ASTAsType(node,type);
	}
}

Token UnaryOperator() :
{
    Token t;
}
{
    ( t = <SUB> | t =<TILDE>)
    {return t;}
}

ASTNode Unary():
{
    Token op = null;
    ASTNode node;
}
{
    (op=UnaryOperator())? node = Fact()
    {
    if (op==null)
        return node;
    switch(op.kind)
    {
        case SUB:
            node = new ASTNegate(node);
            break;
        case TILDE:
            node = new ASTNot(node);
            break;
    }
    return node;
}
}



ASTNode Assignment(ASTNode ref) :
{
	ASTNode exp;
}
{
	<ASSIGNMENT> exp = Expression()
	{ return new ASTAssignment(ref,exp); }
}

ASTNode Fact() :
{
    ASTNode node;
}
{
    (
        node = Constant()
        |
        node = Let()
        |
        node = IfThenElse()
        |
        node = parenthesizedSequence()
        |
        node = Identifier()
        |
        node = NewReference()
        |
        node = Dereference()
        |
        node = Println()
    )
    {
        return node;
    }
}

ASTNode IfThenElse() :
{
	ASTNode cond,pos,neg;
}
{
	<IF> cond = Sequence() <THEN> pos = Sequence() <ELSE> neg = Sequence() <END>
	{ return new ASTTernary(cond,pos,neg); }
}

ASTNode Constant() :
{
    Token primitive;
}
{
   primitive = <INTEGER_LITERAL>
   { return new ASTInteger(Integer.parseInt(primitive.image)); }
   |
   primitive = <FLOAT_LITERAL>
   { return new ASTFloat(Float.parseFloat(primitive.image)); }
   |
   (primitive = <TRUE> | primitive = <FALSE> )
   { return new ASTBoolean(Boolean.parseBoolean(primitive.image)); }
}

ASTNode NewReference() :
{
	ASTNode exp;
}
{
	<NEW> exp = AsType()
	{return new ASTReference(exp);}
}

ASTNode Dereference() :
{
	ASTNode exp;
}
{
	<EXCL> exp = Fact()
	{return new ASTDereference(exp);}
}

ASTNode Identifier() :
{
    Token id;
    ASTNode node;
}
{
    id = <IDENTIFIER>
    {
        node = new ASTIdentifier(id.image);
        return node;
    }
}

Binding Binding() :
{
    Token id;
    ASTNode sequence;
}
{
    id=<IDENTIFIER> <EQUALS> sequence = Sequence()
    { return new Binding(id.image,sequence); }
}

List<Binding> BindingsList() :
{
    Binding d;
    List<Binding> list = new ArrayList<>();
}
{
    d=Binding() {list.add(d);} ((<COMA>)? d= Binding() {list.add(d);})*
    {return list;}

}

ASTNode Let() :
{
    List<Binding> list;
    ASTNode body;
}
{
    <LET>
        list = BindingsList()
    <IN>
        body = Sequence()
    <END>
    { return new ASTLet(list,body); }
}

ASTNode Println() :
{
    ASTNode exp;
}
{
	( <PRINTLN> | <PRINT> ) <LPAR> exp = Sequence() <RPAR>
   { return new ASTPrintln(exp,out); }
}

ASTNode parenthesizedSequence() :
{
    ASTNode node;
}
{
    <LPAR>  node= Sequence()  <RPAR> { return node; }
}
