
options
{
    DEBUG_PARSER=false;
}

PARSER_BEGIN(Parser)

package parser;

import nodes.*;
import state.*;
import java.util.List;
import java.util.ArrayList;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
//|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
//|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN :
{
  < DOT :  "." >
  |
  < COMA : "," >
  |
  < ADD : "+" >
  |
  < SUB : "-" >
  |
  < MULT : "*" >
  |
  < DIV : "/" >
  |
  < EXCL : "!" >
  |
  < CONJ : "&&" >
  |
  < DISJ : "||" >
  |
  < EQUALS : "=" >
  |
  < EQEQ : "==" >
  |
  < EXCL_EQUALS : "!=" >
  |
  < GREATER : ">" >
  |
  < LESS : "<" >
  |
  < GR_EQUALS : ">=" >
  |
  < LE_EQUALS : "<=" >
  |
  < ARROW : "->" >
  |
  < SEMICOLON: ";" >
  |
  < COLON: ":" >
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
//  |
//  < STAT_ENDS: (<SEMICOLON> | <NL>)>
//  |
}

//Reserved words
TOKEN : {
	< LET: "let" > |
	< END: "end" > |
	< IN: "in" > |
	< TRUE: "true" > |
   	< FALSE: "false" >|
   	< PRINTLN: "println" >
}

TOKEN : {
	< INTEGER: (<DIGIT>) + > |
	< FLOAT: (<DIGIT>)+ "." (<DIGIT>)+ > |
	< IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*> |
	< #LETTER: ["a"-"z","A"-"Z","_"]> |
	< #DIGIT: ["0"-"9"]>
}

ASTNode Start():
{
//	List<ASTNode> nodes = new ArrayList<>();
	ASTNode node;
}
{
//   (node = Statment() ((<STAT_ENDS> | <EOF>) Statment())* (<EOF>)?
//   {return node;}
//   )?
    node = Statment()
    {return node;}

}

ASTNode Statment() :
{
 ASTNode node;
}
{
	(
		node = Println() <SEMICOLON>
		|
		node = Expression() <SEMICOLON>
	)
    { return node; }
}

// EXPERIMENTAL -==-----------------------------------
ASTNode Expression() :
{
    ASTNode node;
}
{
    node=Equality()
    { return node; }
}


//ASTNode Disjunction() :
//{
//    ASTNode node;
//}
//{
//    node = Conjunction() ((<NL>)* <DISJ> (<NL>)* Conjunction())*
//    { return node; }
//}
//
//ASTNode Conjunction() :
//{
//    ASTNode node;
//}
//{
//    node = Equality() ((<NL>)* <CONJ> (<NL>)* Equality())*
//    { return node; }
//}

ASTNode Equality() :
{
    Token op;
    ASTNode node;
}
{
    node = Comparison() (( op=<EQEQ> | op=<EXCL_EQUALS> )  Comparison())*
    { return node; }
}

ASTNode Comparison() :
{
    Token op;
    ASTNode node;
}
{
    node = addSubExpression() (( op=<GREATER> | op=<LESS> | op=<GR_EQUALS> | op=<LE_EQUALS> )
      addSubExpression())?
     { return node; }
}

ASTNode addSubExpression() :
{
    Token op;
    ASTNode node, node2;
}
{
    node = multDivExpression() (( op=<ADD> | op=<SUB> )  node2=multDivExpression()
                     { if (op.kind == ADD)
                             node = new ASTAddition(node,node2);
                       else  node = new ASTSubtraction(node,node2);
                     }
               )*
     { return node; }
}

ASTNode multDivExpression() :
{
    Token op;
    ASTNode node, node2;
}
{
    node = Unary() (( op=<MULT> | op=<DIV> ) node2=Unary()
                  { if (op.kind == MULT)
                          node = new ASTMultiplication(node,node2);
                    else  node = new ASTDivision(node,node2);
                  }
           ) *
     { return node; }
}

Token UnaryOperator() :
{
    Token t;
}
{
    ( t = <SUB> | t =<EXCL> )
    {return t;}
}

ASTNode Unary():
{
    Token op = null;
    ASTNode node;
}
{
    (op=UnaryOperator())? node = Fact()
    {
        if (op==null)
            return node;
        switch(op.kind)
        {
            case SUB:
                node = new ASTNegate(node);
                break;
            case EXCL:
                node = new ASTNot(node);
                break;
        }
        return node;
    }
}

ASTNode Fact() :
{
    ASTNode node;
}
{
    (
    	node = Boolean()
    	|
        node = Identifier()
        |
        node = Let()
        |
        node = parenthesizedExpression()
        |
        node = Float()
        |
        node = Integer()
    )
    {
        return node;
    }
}

ASTNode Identifier() :
{
    Token id;
    ASTNode node;
}
{
    id = <IDENTIFIER>
    {
        node = new ASTIdentifier(id.image);
        return node;
    }
}

Binding Binding() :
{
    Token id;
    ASTNode exp;
}
{
    id=<IDENTIFIER> <EQUALS> exp=Expression()
    { return new Binding(id.image,exp); }
}

List<Binding> BindingsList() :
{
    Binding d;
    List<Binding> list = new ArrayList<>();
}
{
    d=Binding() {list.add(d);} ((<COMA>)? d= Binding() {list.add(d);})*
    {return list;}

}

ASTNode Let() :
{
    List<Binding> list;
    ASTNode body;
}
{
    <LET>
        list = BindingsList()
    <IN>
        body = Expression()
    <END>
    { return new nodes.ASTLet(list,body); }
}

ASTNode Integer() :
{
    Token num;
}
{
   num = <INTEGER>
   { return new ASTInteger(Integer.parseInt(num.image)); }
}

ASTNode Float() :
{
    Token num;
}
{
   num = <FLOAT>
   { return new ASTFloat(Float.parseFloat(num.image)); }
}

ASTNode Boolean() :
{
    Token value;
}
{
   (value = <TRUE> | value = <FALSE> )
   { return new ASTBoolean(Boolean.parseBoolean(value.image)); }
}

ASTNode Println() :
{
    ASTNode exp;
}
{
	<PRINTLN> <LPAR> exp = Expression() <RPAR>
   { return new ASTPrintln(exp); }
}

ASTNode parenthesizedExpression() :
{
    ASTNode node;
}
{
    <LPAR>  node=Expression()  <RPAR> { return node; }
}
