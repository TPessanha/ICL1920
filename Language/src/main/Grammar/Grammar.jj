
options
{
    DEBUG_PARSER=false;
    DEBUG_TOKEN_MANAGER=false;
    LOOKAHEAD = 1;
}

PARSER_BEGIN(Parser)

package parser;

import nodes.*;
import nodes.primitives.*;
import nodes.arithmetic.*;
import nodes.relation.*;
import nodes.references.*;
import nodes.logic.*;
import nodes.functions.*;
import nodes.conditional.*;
import state.*;
import types.*;
import java.io.PrintStream;
import java.util.List;
import java.util.ArrayList;


public class Parser {
	PrintStream out;

	public void setOutputStream(PrintStream out)
    {
    	this.out = out;
    }
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN :
{
  < DOT :  "." > |
  < COMMA : "," > |
  < ADD : "+" > |
  < SUB : "-" > |
  < MULT : "*" > |
  < DIV : "/" > |
  < EXCL : "!" > |
  < TILDE : "~" > |
  < CONJ : "&&" > |
  < EAGER_CONJ : "&" > |
  < DISJ : "||" > |
  < EAGER_DISJ : "|" > |
  < EQUALS : "=" > |
  < ASSIGNMENT : ":=" > |
  < EQEQ : "==" > |
  < EXCL_EQUALS : "!=" > |
  < GREATER : ">" > |
  < LESS : "<" > |
  < GR_EQUALS : ">=" > |
  < LE_EQUALS : "<=" > |
  < ARROW : "->" > |
  < SEMICOLON: ";" > |
  < DOUBLE_SEMICOLON: ";;" > |
  < COLON: ":" > |
  < LPAR : "(" > |
  < RPAR : ")" > |
  < LCUR : "{" > |
  < RCUR : "}" >
//  |
//  < STAT_ENDS: (<SEMICOLON> | <NL>)>
//  |
}

//Reserved words
TOKEN : {
	< LET: "let" > |
	< END: "end" > |
	< IN: "in" > |
	< TRUE: "true" > |
   	< FALSE: "false" > |
   	< NEW: "new" > |
   	< AS: "as" > |
   	< IF: "if" > |
   	< THEN: "then" > |
   	< ELSE: "else" > |
   	< WHILE: "while" > |
	< DO: "do" > |
	< FUN: "fun" > |
   	< INSTANCEOF: "instanceof" > |
   	< PRINTLN: "println" > |
   	< PRINT: "print" >
}

//Types
TOKEN : {
   	< INT: "int" > |
   	< FLOAT: "float" > |
   	< BOOLEAN: "boolean" > |
   	< ANY: "any" > |
   	< VOID: "void" > |
   	< REFERENCE: "ref" >
}

TOKEN : {
	< INTEGER_LITERAL: (<DIGIT>) + > |
	< FLOAT_LITERAL: (<DIGIT>)+ "." (<DIGIT>)+ > |
	< IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")*> |
	< #LETTER: ["a"-"z","A"-"Z"]> |
	< #DIGIT: ["0"-"9"]>
}

ASTNode Start():
{
//	List<ASTNode> nodes = new ArrayList<>();
	ASTNode node, node2;
}
{
//   (node = Statment() ((<STAT_ENDS> | <EOF>) Statment())* (<EOF>)?
//   {return node;}
//   )?
    node = Sequence() <DOUBLE_SEMICOLON>
    {return node;}

}

ASTNode Sequence() :
{
	ASTNode node, node2;
}
{
	node = Statment() ( <SEMICOLON> node2 = Statment()
    	{
        	node = new ASTSequence(node,node2);
    	}
    )*
    {return node;}
}

ASTNode Statment() :
{
	ASTNode node;
}
{
	(
		node = Expression()
		|
		node = While()
	)
    { return node; }
}

ASTStatement While() :
{
	ASTNode cond, body;
}
{
	<WHILE> cond = Sequence() <DO> body = Sequence() <END>
	{ return new ASTWhile(cond,body); }
}

ASTNode Expression() :
{
    ASTNode node;
}
{
    node=Disjunction()
    { return node; }
}


ASTNode Disjunction() :
{
	Token op;
    ASTNode node,node2;
}
{
    node = Conjunction() (LOOKAHEAD(1)(op = <DISJ> | op = <EAGER_DISJ>) node2 = Conjunction()
    	{
		 	switch(op.kind)
         	{
         		case EAGER_DISJ:
 					node = new ASTEagerOr(node,node2);
 					break;
 				case DISJ:
 					node = new ASTOr(node,node2);
 					break;
         	}
 		}
    )*
    { return node; }
}

ASTNode Conjunction() :
{
	Token op;
    ASTNode node,node2;
}
{
    node = Equality() (LOOKAHEAD(1)(op = <CONJ> | op = <EAGER_CONJ>) node2 = Equality()
    	{
		 	switch(op.kind)
         	{
         		case EAGER_CONJ:
 					node = new ASTEagerAnd(node,node2);
 					break;
 				case CONJ:
 					node = new ASTAnd(node,node2);
 					break;
         	}
 		}
    )*
    { return node; }
}

ASTNode Equality() :
{
    Token op;
    ASTNode node,node2;
}
{
    node = Comparison() (LOOKAHEAD(1)( op=<EQEQ> | op=<EXCL_EQUALS> )  node2=Comparison()
    	{
			switch(op.kind)
   			{
   				case EQEQ:
   					node = new ASTEqual(node,node2);
   					break;
   			    case EXCL_EQUALS:
   			    	node = new ASTNotEqual(node,node2);
   			    	break;
   			}
   		}
    )*
    { return node; }
}

ASTNode Comparison() :
{
    Token op;
    ASTNode node,node2;
}
{
    node = AddSubExpression() (LOOKAHEAD(1) ( op=<GREATER> | op=<LESS> | op=<GR_EQUALS> | op=<LE_EQUALS> )  node2=AddSubExpression()
    	{
			switch(op.kind)
   			{
   				case GREATER:
   					node = new ASTGreater(node,node2);
   					break;
   				case GR_EQUALS:
   					node = new ASTGreaterEqual(node,node2);
   					break;
   			    case LESS:
   			    	node = new ASTLess(node,node2);
   			    	break;
   			    case LE_EQUALS:
   			    	node = new ASTLessEqual(node,node2);
   			    	break;
   			}
   		}
    )?
    { return node; }
}

ASTNode AddSubExpression() :
{
    Token op;
    ASTNode node, node2;
}
{
    node = MultDivExpression()
    (
    	LOOKAHEAD(1)
    ( op=<ADD> | op=<SUB> )  node2=MultDivExpression()
    	{
			if (op.kind == ADD)
				node = new ASTAddition(node,node2);
			else
				node = new ASTSubtraction(node,node2);
		}
    )*
    { return node; }
}

ASTNode MultDivExpression() :
{
    Token op;
    ASTNode node, node2;
}
{
	node = Term()
    (
    	LOOKAHEAD(1)( op=<MULT> | op=<DIV> ) node2 = Term()
		{
			if (op.kind == MULT)
    	    	node = new ASTMultiplication(node,node2);
			else
				node = new ASTDivision(node,node2);
		}
    )*
    { return node; }
}

ASTNode Term() :
{
	ASTNode node;
	Token op;
}
{
	node = AsExpression()
	(
		LOOKAHEAD(1)
		node = Assignment(node)
		|
		node = ApplyFunction(node)
	)?
	{ return node; }
}

IType NumberType() :
{
	IType t;
}
{
	(
		<FLOAT> { t = FloatType.value; } |
		<INT> {t = IntType.value; }
	)
    { return t; }
}


ASTNode AsExpression() :
{
	IType type = null;
    ASTNode node;
}
{
	node = PrefixUnaryExpression() (LOOKAHEAD(1) <AS> type = NumberType() )?
	{
		if (type==null)
    	   	return node;
		else
    	    return new ASTAsType(node,type);
	}
}

Token PrefixUnaryOperator() :
{
    Token t;
}
{
    ( t = <SUB> | t =<TILDE>)
    {return t;}
}

ASTNode PrefixUnaryExpression():
{
    Token op;
    List<Token> ops = new ArrayList<>();
    ASTNode node;
}
{
    (op = PrefixUnaryOperator() { ops.add(op); } )* node = Fact()
    {
    	for(Token t: ops)
    	{
    		switch(t.kind)
            {
            	case SUB:
            		node = new ASTNegate(node);
            		break;
            	case TILDE:
            		node = new ASTNot(node);
            		break;
//                case EXCL:
//                	node = new ASTDereference(node);
//                	break;
            }
    	}
    	return node;
	}
}

ASTNode ApplyFunction(ASTNode function) :
{
	List<ASTNode> arguments;
}
{
	<LPAR> arguments = FunctionArguments() <RPAR>
	{ return new ASTApplyFunction(function,arguments); }
}

List<ASTNode> FunctionArguments() :
{
	List<ASTNode> arguments = new ArrayList<>();
	ASTNode argument;
}
{
	(
		argument = Sequence() { arguments.add(argument); }
		(< COMMA > argument = Sequence() { arguments.add(argument); })*
	)?

	{ return arguments; }
}

ASTNode Assignment(ASTNode ref) :
{
	ASTNode exp;
}
{
	<ASSIGNMENT> exp = Expression()
	{ return new ASTAssignment(ref,exp); }
}

ASTNode Fact() :
{
    ASTNode node;
}
{
    (
        node = Constant()
        |
        node = Let()
        |
        node = IfThenElse()
        |
        node = parenthesizedSequence()
        |
        node = Identifier()
        |
        node = NewReference()
        |
        node = Dereference()
        |
        node = Function()
        |
        node = Println()
    )
    {
        return node;
    }
}

List<String> FunctionParameters() :
{
	List<String> parameters = new ArrayList<>();
	Token identifier;
}
{
	identifier = <IDENTIFIER> { parameters.add(identifier.image); }
	(<COMMA> identifier = <IDENTIFIER> { parameters.add(identifier.image); })*
	{ return parameters; }
}

ASTNode Function() :
{
    List<String> parameters;
    ASTNode body;
}
{

	<FUN>
		parameters = FunctionParameters()
	<ARROW>
		body = Sequence()
	<END>
	{ return new ASTFunction(parameters,body); }
}

ASTNode IfThenElse() :
{
	ASTNode cond,pos,neg;
}
{
	<IF> cond = Sequence() <THEN> pos = Sequence() <ELSE> neg = Sequence() <END>
	{ return new ASTTernary(cond,pos,neg); }
}

ASTNode Constant() :
{
    Token primitive;
}
{
   primitive = <INTEGER_LITERAL>
   { return new ASTInteger(Integer.parseInt(primitive.image)); }
   |
   primitive = <FLOAT_LITERAL>
   { return new ASTFloat(Float.parseFloat(primitive.image)); }
   |
   (primitive = <TRUE> | primitive = <FALSE> )
   { return new ASTBoolean(Boolean.parseBoolean(primitive.image)); }
}

ASTNode NewReference() :
{
	ASTNode exp;
}
{
	<NEW> exp = Expression()
	{return new ASTReference(exp);}
}

ASTNode Dereference() :
{
	ASTNode exp;
}
{
	<EXCL> exp = Fact()
	{return new ASTDereference(exp);}
}

IType PrimitiveType() :
{
	IType t;
}
{
	(
		t = NumberType()
		|
		< BOOLEAN > { t = BooleanType.value; }

	)
    { return t; }
}

IType Type() :
{
	IType t;
}
{
	(
		t = PrimitiveType()
		|
		< ANY > { t = AnyType.value; }
		|
		< VOID > { t = VoidType.value; }

	)
	{ return t; }
}

ASTNode Identifier() :
{
    Token id;
    ASTNode node;
}
{
    id = <IDENTIFIER>
    {
        node = new ASTIdentifier(id.image);
        return node;
    }
}

Binding Binding() :
{
    Token id;
    ASTNode sequence;
}
{
    id=<IDENTIFIER> <EQUALS> sequence = Sequence()
    { return new Binding(id.image,sequence); }
}

List<Binding> BindingsList() :
{
    Binding d;
    List<Binding> list = new ArrayList<>();
}
{
    d=Binding() {list.add(d);} ((<COMMA>)? d= Binding() {list.add(d);})*
    {return list;}

}

ASTNode Let() :
{
    List<Binding> list;
    ASTNode body;
}
{
    <LET>
        list = BindingsList()
    <IN>
        body = Sequence()
    <END>
    { return new ASTLet(list,body); }
}

ASTNode Println() :
{
    ASTNode exp;
}
{
	( <PRINTLN> | <PRINT> ) <LPAR> exp = Sequence() <RPAR>
   { return new ASTPrintln(exp,out); }
}

ASTNode parenthesizedSequence() :
{
    ASTNode node;
}
{
    <LPAR>  node= Sequence()  <RPAR> { return node; }
}
