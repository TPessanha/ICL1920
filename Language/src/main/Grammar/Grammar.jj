
options
{
    DEBUG_PARSER=false;
}

PARSER_BEGIN(Parser)

package parser;

import nodes.*;
import nodes.primitives.*;
import nodes.arithmetic.*;
import nodes.relation.*;
import nodes.logic.*;
import state.*;
import java.util.List;
import java.util.ArrayList;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN :
{
  < DOT :  "." >
  |
  < COMA : "," >
  |
  < ADD : "+" >
  |
  < SUB : "-" >
  |
  < MULT : "*" >
  |
  < DIV : "/" >
  |
  < EXCL : "!" >
  |
  < CONJ : "&&" >
  |
  < DISJ : "||" >
  |
  < EQUALS : "=" >
  |
  < EQEQ : "==" >
  |
  < EXCL_EQUALS : "!=" >
  |
  < GREATER : ">" >
  |
  < LESS : "<" >
  |
  < GR_EQUALS : ">=" >
  |
  < LE_EQUALS : "<=" >
  |
  < ARROW : "->" >
  |
  < SEMICOLON: ";" >
  |
  < COLON: ":" >
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < LCUR : "{" >
  |
  < RCUR : "}" >
//  |
//  < STAT_ENDS: (<SEMICOLON> | <NL>)>
//  |
}

//Reserved words
TOKEN : {
	< LET: "let" > |
	< END: "end" > |
	< IN: "in" > |
	< TRUE: "true" > |
   	< FALSE: "false" > |
   	< INT: "int" > |
   	< FLOAT: "float" >|
   	< PRINTLN: "println" >
}

TOKEN : {
	< INTEGER_LITERAL: (<DIGIT>) + > |
	< FLOAT_LITERAL: (<DIGIT>)+ "." (<DIGIT>)+ > |
	< IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*> |
	< #LETTER: ["a"-"z","A"-"Z","_"]> |
	< #DIGIT: ["0"-"9"]>
}

ASTNode Start():
{
//	List<ASTNode> nodes = new ArrayList<>();
	ASTNode node;
}
{
//   (node = Statment() ((<STAT_ENDS> | <EOF>) Statment())* (<EOF>)?
//   {return node;}
//   )?
    node = Statment()
    {return node;}

}

ASTNode Statment() :
{
 ASTNode node;
}
{
	(
		node = Println() <SEMICOLON>
		|
		node = Expression() <SEMICOLON>
	)
    { return node; }
}

// EXPERIMENTAL -==-----------------------------------
ASTExpression Expression() :
{
    ASTExpression node;
}
{
    node=Disjunction()
    { return node; }
}


ASTExpression Disjunction() :
{
    ASTExpression node,node2;
}
{
    node = Conjunction() ( <DISJ> node2 = Conjunction()
    	{
        	node = new ASTOr(node,node2);
        }
    )*
    { return node; }
}

ASTExpression Conjunction() :
{
    ASTExpression node,node2;
}
{
    node = Equality() (<CONJ> node2 = Equality()
    	{
    		node = new ASTAnd(node,node2);
    	}
    )*
    { return node; }
}

ASTExpression Equality() :
{
    Token op;
    ASTExpression node,node2;
}
{
    node = Comparison() (( op=<EQEQ> | op=<EXCL_EQUALS> )  node2=Comparison()
    	{
			switch(op.kind)
   			{
   				case EQEQ:
   					node = new ASTEqual(node,node2);
   					break;
   			    case EXCL_EQUALS:
   			    	node = new ASTNotEqual(node,node2);
   			    	break;
   			}
   		}
    )*
    { return node; }
}

ASTExpression Comparison() :
{
    Token op;
    ASTExpression node,node2;
}
{
    node = addSubExpression() (( op=<GREATER> | op=<LESS> | op=<GR_EQUALS> | op=<LE_EQUALS> )  node2=addSubExpression()
    	{
			switch(op.kind)
   			{
   				case GREATER:
   					node = new ASTGreater(node,node2);
   					break;
   				case GR_EQUALS:
   					node = new ASTGreaterEqual(node,node2);
   					break;
   			    case LESS:
   			    	node = new ASTLess(node,node2);
   			    	break;
   			    case LE_EQUALS:
   			    	node = new ASTLessEqual(node,node2);
   			    	break;
   			}
   		}
    )?
    { return node; }
}

ASTExpression addSubExpression() :
{
    Token op;
    ASTExpression node, node2;
}
{
    node = multDivExpression() (( op=<ADD> | op=<SUB> )  node2=multDivExpression()
                     { if (op.kind == ADD)
        node = new nodes.arithmetic.ASTAddition(node,node2);
  else  node = new nodes.arithmetic.ASTSubtraction(node,node2);
}
               )*
     { return node; }
}

ASTExpression multDivExpression() :
{
    Token op;
    ASTExpression node, node2;
}
{
    node = Cast() (( op=<MULT> | op=<DIV> ) node2=Cast()
                  { if (op.kind == MULT)
        node = new nodes.arithmetic.ASTMultiplication(node,node2);
  else  node = new nodes.arithmetic.ASTDivision(node,node2);
}
           ) *
    { return node; }
}

Token PrimitiveType() :
{
	Token t;
}
{
	( t = <FLOAT> | t = <INT> )
    {return t;}
}


ASTExpression Cast() :
{
	Token type = null;
    ASTExpression node;
}
{
	(<LCUR> type = PrimitiveType() <RCUR> )? node = Unary()
	{
		if (type==null)
        	return node;
        else
	        return new ASTCast(node,type.image);
	}
}

Token UnaryOperator() :
{
    Token t;
}
{
    ( t = <SUB> | t =<EXCL>)
    {return t;}
}

ASTExpression Unary():
{
    Token op = null;
    ASTExpression node;
}
{
    (op=UnaryOperator())? node = Fact()
    {
    if (op==null)
        return node;
    switch(op.kind)
    {
        case SUB:
            node = new ASTNegate(node);
            break;
        case EXCL:
            node = new nodes.logic.ASTNot(node);
            break;
    }
    return node;
}
}


ASTExpression Fact() :
{
    ASTExpression node;
}
{
    (
    	node = Boolean()
    	|
        node = Identifier()
        |
        node = Let()
        |
        node = parenthesizedExpression()
        |
        node = Float()
        |
        node = Integer()
    )
    {
        return node;
    }
}

ASTExpression Identifier() :
{
    Token id;
    ASTExpression node;
}
{
    id = <IDENTIFIER>
    {
        node = new ASTIdentifier(id.image);
        return node;
    }
}

Binding Binding() :
{
    Token id;
    ASTExpression exp;
}
{
    id=<IDENTIFIER> <EQUALS> exp=Expression()
    { return new Binding(id.image,exp); }
}

List<Binding> BindingsList() :
{
    Binding d;
    List<Binding> list = new ArrayList<>();
}
{
    d=Binding() {list.add(d);} ((<COMA>)? d= Binding() {list.add(d);})*
    {return list;}

}

ASTExpression Let() :
{
    List<Binding> list;
    ASTExpression body;
}
{
    <LET>
        list = BindingsList()
    <IN>
        body = Expression()
    <END>
    { return new ASTLet(list,body); }
}

ASTExpression Integer() :
{
    Token num;
}
{
   num = <INTEGER_LITERAL>
   { return new ASTInteger(Integer.parseInt(num.image)); }
}

ASTExpression Float() :
{
    Token num;
}
{
   num = <FLOAT_LITERAL>
   { return new ASTFloat(Float.parseFloat(num.image)); }
}

ASTExpression Boolean() :
{
    Token value;
}
{
   (value = <TRUE> | value = <FALSE> )
   { return new ASTBoolean(Boolean.parseBoolean(value.image)); }
}

ASTNode Println() :
{
    ASTExpression exp;
}
{
	<PRINTLN> <LPAR> exp = Expression() <RPAR>
   { return new ASTPrintln(exp); }
}

ASTExpression parenthesizedExpression() :
{
    ASTExpression node;
}
{
    <LPAR>  node=Expression()  <RPAR> { return node; }
}
